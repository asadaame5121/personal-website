<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <title>ホームページ</title>
</head>

<body>
{{ comp.header() | safe }}
<div id="canvas-container"></div>

<script>
    // シーンの作成
    const scene = new THREE.Scene();
    
    // カメラの設定（遠近感をなくすためにOrthographicCameraを使用）
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.OrthographicCamera(-5 * aspect, 5 * aspect, 5, -5, 0.1, 100);
    camera.position.set(10, 5, 10); // カメラの位置を下げる
    camera.lookAt(0, -2, 0); // カメラの角度を調整
    
    // レンダラーの設定
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight - 180); // ヘッダーとフッターの高さを考慮
    renderer.shadowMap.enabled = true;
    
    // DOMが読み込まれた後にレンダラーを追加
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('canvas-container').appendChild(renderer.domElement);
    });
    
    // シーン全体の位置調整用のグループ
    const sceneGroup = new THREE.Group();
    scene.add(sceneGroup);
    
    // シーンを下に移動してフッターに接するように調整
    sceneGroup.position.y = -5; // さらに下に移動
    
    // ライトの追加
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 5, 10); // ライトの位置を下げる
    light.castShadow = true;
    sceneGroup.add(light);
    sceneGroup.add(new THREE.AmbientLight(0x404040));
    
    // タイルマップの作成
    const tileSize = 1;
    const gridSize = 5;
    const tiles = [];
    
    function createTextTexture(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 128;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        return new THREE.CanvasTexture(canvas);
    }

    // カテゴリー名を定義
    const categories = {
        1: 'Resources',
        6: 'Article',
        11: 'Grossary',
        16: 'Person',
        21: 'Others'
    };

    // カテゴリごとの記事数
    const categoryArticleCounts = {
        'Resources': 1000,
        'Article': 20,
        'Grossary': 50,  // 仮の値
        'Person': 1000,
        'Others': 100    // 仮の値
    };

    // 記事数から高さを計算する関数
    function calculateHeightFromCount(count) {
        // 対数スケールで高さを計算（値の範囲が広いため）
        const minHeight = 1;
        const maxHeight = 5;
        const minCount = 10;  // 最小記事数（これより少ない場合は最小高さ）
        const maxCount = 1000; // 最大記事数（これより多い場合は最大高さ）
        
        if (count <= minCount) return minHeight;
        if (count >= maxCount) return maxHeight;
        
        // 対数スケールで高さを計算
        const logMinCount = Math.log(minCount);
        const logMaxCount = Math.log(maxCount);
        const logCount = Math.log(count);
        
        // 正規化して高さの範囲にマッピング
        const normalizedHeight = (logCount - logMinCount) / (logMaxCount - logMinCount);
        return minHeight + normalizedHeight * (maxHeight - minHeight);
    }

    let counter = 1;
    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
            const geometry = new THREE.BoxGeometry(tileSize, tileSize, tileSize);
            
            // カテゴリータイルの色を変更
            let tileColor = 0x6B8E23; // デフォルト色
            let tileHeight = 1; // デフォルト高さ
            
            if (categories[counter]) {
                tileColor = 0x4682B4; // カテゴリータイルの色
                const categoryName = categories[counter];
                const articleCount = categoryArticleCounts[categoryName];
                tileHeight = calculateHeightFromCount(articleCount);
            }
            
            const material = new THREE.MeshLambertMaterial({ color: tileColor });
            const tile = new THREE.Mesh(geometry, material);
            
            // 高さに基づいてスケールと位置を調整
            tile.scale.y = tileHeight;
            
            tile.position.set(
                (x - gridSize / 2) * tileSize,
                tileHeight * tileSize / 2, // 高さに応じて位置調整
                (z - gridSize / 2) * tileSize
            );
            tile.castShadow = true;
            tile.receiveShadow = true;
            
            // テキスト表示（カテゴリーまたは番号）
            const displayText = categories[counter] || counter.toString();
            const textSize = categories[counter] ? 0.7 : 1; // カテゴリー名は小さめに
            
            const textMaterial = new THREE.MeshBasicMaterial({ map: createTextTexture(displayText), transparent: true });
            const textGeometry = new THREE.PlaneGeometry(tileSize * textSize, tileSize * textSize);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(tile.position.x, tileHeight * tileSize + 0.1, tile.position.z);
            textMesh.rotation.x = -Math.PI / 2;
            sceneGroup.add(textMesh);
            
            sceneGroup.add(tile);
            tiles.push(tile);
            counter++;
        }
    }
    
    // Raycasterを使ってクリックしたタイルを検出
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / (window.innerHeight - 180)) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tiles);
        
        if (intersects.length > 0) {
            const tile = intersects[0].object;
            const tileIndex = tiles.indexOf(tile);
            const tileNumber = tileIndex + 1;
            
            if (categories[tileNumber]) {
                const categoryName = categories[tileNumber];
                const count = categoryArticleCounts[categoryName];
                console.log(`${categoryName}: ${count}記事`);
                // カテゴリータイルをクリックした場合の処理
                // 将来的にはここでカテゴリーページへの遷移などを実装
            } else {
                // 通常のタイルをクリックした場合の処理
                console.log(`タイル番号: ${tileNumber}`);
            }
        }
    });
    
    // ウィンドウのリサイズ対応
    window.addEventListener('resize', () => {
        const newAspect = window.innerWidth / (window.innerHeight - 180);
        camera.left = -5 * newAspect;
        camera.right = 5 * newAspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight - 180);
    });
    
    // アニメーションループ
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();
</script>

<style>
    body { 
        margin: 0; 
        padding: 0;
        overflow: hidden; 
        display: flex;
        flex-direction: column;
        height: 100vh;
    }
    #canvas-container {
        flex: 1;
        position: relative;
        display: flex;
        align-items: flex-end; /* Canvasを下寄せにする */
        overflow: hidden;
    }
</style>
{{ comp.footer() | safe }}
</body>
</html>
