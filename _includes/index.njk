<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="/assets/styles.css">
    <title>DropGarden</title>
</head>

<body>

<div id="canvas-container"></div>

<script>
    // シーンの作成
    const scene = new THREE.Scene();
    
    // カメラの設定（遠近感をなくすためにOrthographicCameraを使用）
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.OrthographicCamera(-10 * aspect, 10 * aspect, 10, -10, 0.1, 100);
    camera.position.set(15, 10, 15); // カメラの位置を調整
    camera.lookAt(0, -2, 0); // カメラの角度を調整
    
    // レンダラーの設定
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight); // ウィンドウ全体を使用
    renderer.shadowMap.enabled = true;
    
    // DOMが読み込まれた後にレンダラーを追加
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('canvas-container').appendChild(renderer.domElement);
    });
    
    // シーン全体の位置調整用のグループ
    const sceneGroup = new THREE.Group();
    scene.add(sceneGroup);
    
    // シーンを下に移動して調整
    sceneGroup.position.y = -5; // 位置調整
    
    // ライトの追加
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(15, 10, 15); // ライトの位置を調整
    light.castShadow = true;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 50;
    light.shadow.camera.left = -20;
    light.shadow.camera.right = 20;
    light.shadow.camera.top = 20;
    light.shadow.camera.bottom = -20;
    sceneGroup.add(light);
    sceneGroup.add(new THREE.AmbientLight(0x404040));
    
    // タイルマップの作成
    const tileSize = 1;
    const gridSize = 12; // グリッドサイズを拡大
    const tiles = [];
    
    function createTextTexture(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 128;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        return new THREE.CanvasTexture(canvas);
    }

    // カテゴリー名を定義
    const categories = {
        1: 'Resources',
        6: 'Article',
        11: 'Grossary',
        16: 'Person',
        21: 'Others',
        // 追加カテゴリー
        36: 'Projects',
        48: 'Books',
        60: 'Media',
        72: 'Tools',
        100: 'Archive'
    };

    // カテゴリごとの記事数
    const categoryArticleCounts = {
        'Resources': 1000,
        'Article': 20,
        'Grossary': 50,
        'Person': 1000,
        'Others': 100,
        // 追加カテゴリーの記事数
        'Projects': 30,
        'Books': 200,
        'Media': 80,
        'Tools': 45,
        'Archive': 500
    };

    // 記事数から高さを計算する関数
    function calculateHeightFromCount(count) {
        // 対数スケールで高さを計算（値の範囲が広いため）
        const minHeight = 1;
        const maxHeight = 5;
        const minCount = 10;  // 最小記事数（これより少ない場合は最小高さ）
        const maxCount = 1000; // 最大記事数（これより多い場合は最大高さ）
        
        if (count <= minCount) return minHeight;
        if (count >= maxCount) return maxHeight;
        
        // 対数スケールで高さを計算
        const logMinCount = Math.log(minCount);
        const logMaxCount = Math.log(maxCount);
        const logCount = Math.log(count);
        
        // 正規化して高さの範囲にマッピング
        const normalizedHeight = (logCount - logMinCount) / (logMaxCount - logMinCount);
        return minHeight + normalizedHeight * (maxHeight - minHeight);
    }

    let counter = 1;
    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
            const geometry = new THREE.BoxGeometry(tileSize, tileSize, tileSize);
            
            // カテゴリータイルの色を変更
            let tileColor = 0x6B8E23; // デフォルト色
            let tileHeight = 1; // デフォルト高さ
            
            if (categories[counter]) {
                tileColor = 0x4682B4; // カテゴリータイルの色
                const categoryName = categories[counter];
                const articleCount = categoryArticleCounts[categoryName];
                tileHeight = calculateHeightFromCount(articleCount);
            }
            
            const material = new THREE.MeshLambertMaterial({ color: tileColor });
            const tile = new THREE.Mesh(geometry, material);
            
            // 高さに基づいてスケールと位置を調整
            tile.scale.y = tileHeight;
            
            tile.position.set(
                (x - gridSize / 2) * tileSize,
                tileHeight * tileSize / 2, // 高さに応じて位置調整
                (z - gridSize / 2) * tileSize
            );
            tile.castShadow = true;
            tile.receiveShadow = true;
            
            // テキスト表示（カテゴリーまたは番号）
            const displayText = categories[counter] || counter.toString();
            const textSize = categories[counter] ? 0.7 : 0.5; // テキストサイズを調整
            
            const textMaterial = new THREE.MeshBasicMaterial({ map: createTextTexture(displayText), transparent: true });
            const textGeometry = new THREE.PlaneGeometry(tileSize * textSize, tileSize * textSize);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(tile.position.x, tileHeight * tileSize + 0.1, tile.position.z);
            textMesh.rotation.x = -Math.PI / 2;
            sceneGroup.add(textMesh);
            
            sceneGroup.add(tile);
            tiles.push(tile);
            counter++;
        }
    }
    
    // Raycasterを使ってクリックしたタイルを検出
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tiles);
        
        if (intersects.length > 0) {
            const tile = intersects[0].object;
            const tileIndex = tiles.indexOf(tile);
            const tileNumber = tileIndex + 1;
            
            if (categories[tileNumber]) {
                const categoryName = categories[tileNumber];
                const count = categoryArticleCounts[categoryName];
                console.log(`${categoryName}: ${count}記事`);
                // カテゴリータイルをクリックした場合の処理
                // 将来的にはここでカテゴリーページへの遷移などを実装
            } else {
                // 通常のタイルをクリックした場合の処理
                console.log(`タイル番号: ${tileNumber}`);
            }
        }
    });
    
    // ウィンドウのリサイズ対応
    window.addEventListener('resize', () => {
        const newAspect = window.innerWidth / window.innerHeight;
        camera.left = -10 * newAspect;
        camera.right = 10 * newAspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // アニメーションループ
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();
</script>

<style>
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
    }
    
    #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }
</style>

</body>
</html>
