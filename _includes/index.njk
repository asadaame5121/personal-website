<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="/assets/styles.css">
    <title>DropGarden</title>
</head>

<body>

<div id="canvas-container"></div>

<script>
    // シーンの作成
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xF2EFE2); // イングリッシュガーデンの象牙色に設定
    
    // テクスチャーローダーの作成
    const textureLoader = new THREE.TextureLoader();
    
    // テクスチャーの読み込み
    const waterTexture = textureLoader.load('/assets/images/Tiles/water_center_N.png');
    const grassTexture = textureLoader.load('/assets/images/Tiles/grass_center_N.png');
    const sandTexture = textureLoader.load('/assets/images/Tiles/sand_center_N.png');
    
    // テクスチャーの繰り返し設定
    waterTexture.wrapS = THREE.RepeatWrapping;
    waterTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.wrapS = THREE.RepeatWrapping;
    grassTexture.wrapT = THREE.RepeatWrapping;
    sandTexture.wrapS = THREE.RepeatWrapping;
    sandTexture.wrapT = THREE.RepeatWrapping;
    
    // カメラの設定（遠近感をなくすためにOrthographicCameraを使用）
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.OrthographicCamera(-10 * aspect, 10 * aspect, 10, -10, 0.1, 100);
    camera.position.set(15, 10, 15); // カメラの位置を調整
    camera.lookAt(0, -2, 0); // カメラの角度を調整
    
    // レンダラーの設定
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight); // ウィンドウ全体を使用
    renderer.shadowMap.enabled = true;
    
    // DOMが読み込まれた後にレンダラーを追加
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('canvas-container').appendChild(renderer.domElement);
    });
    
    // シーン全体の位置調整用のグループ
    const sceneGroup = new THREE.Group();
    scene.add(sceneGroup);
    
    // シーンを下に移動して調整
    sceneGroup.position.y = -5; // 位置調整
    
    // ライトの追加
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(15, 10, 15); // ライトの位置を調整
    light.castShadow = true;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 50;
    light.shadow.camera.left = -20;
    light.shadow.camera.right = 20;
    light.shadow.camera.top = 20;
    light.shadow.camera.bottom = -20;
    sceneGroup.add(light);
    sceneGroup.add(new THREE.AmbientLight(0x404040));
    
    // タイルマップの作成
    const tileSize = 1;
    const maxGridSize = 20; // 最大グリッドサイズ
    const minGridSize = 3;  // 最小グリッドサイズ
    const tiles = [];
    
    // 背景タイルのサイズと範囲
    const bgTileSize = 1;
    const bgGridSize = 40; // 背景グリッドは非常に広く
    const bgTileHeight = 0.2; // 背景タイルは低く
    
    // 土と砂浜の色を定義
    const landColors = {
        sand: 0xE2C391, // 砂浜の黄金色
        shallowSand: 0xD8C3A5, // 浅瀬の砂色
        volcanicSoil: 0x5D4037, // 火山性の暗褐色
        coralSand: 0xF5D6C6, // 珊瑚砂の薄桃色
        tropicalSoil: 0x8B4513 // 熱帯土壌の赤褐色
    };
    
    // 大陸型配置の設定
    const continentConfig = {
        centerSize: 6, // 中央の正方形エリアのサイズ
        riverColor: 0x40BCD8, // 川の色（カリビアンターコイズ）
        mainLandColor: 0x2E6D32, // 主要な土地の色（熱帯の緑）
        categoryColors: {
            'Resources': 0x1A3A5F, // 海洋の深いブルー
            'Article': 0x2E6D32, // 熱帯の緑
            'Glossary': 0xE8D0AA // アンティーク地図の古紙色
        },
        topicnoteColor: 0xFFCC33 // Topicnote用の色（黄金/コイン色）
    };
    
    // ボロノイ図生成のためのライブラリ（d3-voronoi）の代わりに簡易的な実装
    function createContinentMap(gridSize) {
        // カテゴリーの位置を決定
        const categoryPositions = {
            'Resources': { x: -Math.floor(gridSize/4), z: -Math.floor(gridSize/4) },
            'Article': { x: Math.floor(gridSize/4), z: -Math.floor(gridSize/4) },
            'Glossary': { x: 0, z: Math.floor(gridSize/4) }
        };
        
        // 中央にTopicnote用の6x6エリアを確保
        const topicnoteArea = {
            startX: -Math.floor(continentConfig.centerSize/2),
            endX: Math.floor(continentConfig.centerSize/2),
            startZ: -Math.floor(continentConfig.centerSize/2),
            endZ: Math.floor(continentConfig.centerSize/2)
        };
        
        // 各タイルの情報を格納する配列
        const continentTiles = [];
        
        // グリッド全体をループ
        for (let x = -Math.floor(gridSize/2); x < Math.ceil(gridSize/2); x++) {
            for (let z = -Math.floor(gridSize/2); z < Math.ceil(gridSize/2); z++) {
                // タイルの種類を決定
                let tileType = 'land'; // デフォルトは土地
                let category = null;
                let height = bgTileHeight;
                let color = continentConfig.mainLandColor;
                
                // 中央のTopicnoteエリア内かチェック
                if (x >= topicnoteArea.startX && x <= topicnoteArea.endX && 
                    z >= topicnoteArea.startZ && z <= topicnoteArea.endZ) {
                    tileType = 'topicnote';
                    color = continentConfig.topicnoteColor;
                    height = 0.5; // Topicnoteエリアは少し高く
                } 
                // カテゴリーエリアかチェック
                else {
                    // 各カテゴリーからの距離を計算
                    let minDistance = Infinity;
                    let closestCategory = null;
                    
                    for (const [catName, pos] of Object.entries(categoryPositions)) {
                        const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCategory = catName;
                        }
                    }
                    
                    // カテゴリーの中心に近いほど高く
                    const categoryPos = categoryPositions[closestCategory];
                    const distanceFromCenter = Math.sqrt(Math.pow(x - categoryPos.x, 2) + Math.pow(z - categoryPos.z, 2));
                    
                    // カテゴリーの記事数に基づいて影響範囲を決定
                    const categoryInfluence = Math.sqrt(categoryArticleCounts[closestCategory]) / 5;
                    
                    if (distanceFromCenter < 1) {
                        // カテゴリーの中心
                        tileType = 'category';
                        category = closestCategory;
                        color = continentConfig.categoryColors[closestCategory];
                        height = calculateHeightFromCount(categoryArticleCounts[closestCategory]);
                    } else if (distanceFromCenter < categoryInfluence) {
                        // カテゴリーの影響範囲内
                        tileType = 'article';
                        category = closestCategory;
                        color = continentConfig.categoryColors[closestCategory];
                        
                        // 中心からの距離に応じて高さを減少
                        const heightRatio = 1 - (distanceFromCenter / categoryInfluence);
                        height = bgTileHeight + heightRatio * (calculateHeightFromCount(categoryArticleCounts[closestCategory]) - bgTileHeight);
                    }
                    
                    // カテゴリー間の境界に川を配置
                    if (tileType === 'land') {
                        // 最も近いカテゴリーと2番目に近いカテゴリーの距離の差が小さい場合は川
                        let secondMinDistance = Infinity;
                        
                        for (const [catName, pos] of Object.entries(categoryPositions)) {
                            if (catName !== closestCategory) {
                                const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                                if (distance < secondMinDistance) {
                                    secondMinDistance = distance;
                                }
                            }
                        }
                        
                        if (Math.abs(minDistance - secondMinDistance) < 1) {
                            tileType = 'river';
                            color = continentConfig.riverColor;
                            height = bgTileHeight * 0.5; // 川は低く
                        }
                    }
                }
                
                continentTiles.push({
                    x,
                    z,
                    type: tileType,
                    category,
                    height,
                    color
                });
            }
        }
        
        return continentTiles;
    }
    
    // 背景タイルの作成（メインのグリッド範囲内はスキップ）
    for (let x = -bgGridSize/2; x < bgGridSize/2; x++) {
        for (let z = -bgGridSize/2; z < bgGridSize/2; z++) {
            // メインのグリッド範囲内はスキップ（後で別に描画）
            if (x >= -maxGridSize/2 && x < maxGridSize/2 && z >= -maxGridSize/2 && z < maxGridSize/2) {
                continue;
            }
            
            const geometry = new THREE.BoxGeometry(bgTileSize, bgTileHeight, bgTileSize);
            const material = new THREE.MeshLambertMaterial({ 
                map: sandTexture,
                color: 0xFFFFFF, // テクスチャーの色を活かすために白色
                opacity: 0.8,
                transparent: true
            });
            const bgTile = new THREE.Mesh(geometry, material);
            
            bgTile.position.set(
                x * bgTileSize,
                bgTileHeight / 2, // 高さの半分
                z * bgTileSize
            );
            bgTile.receiveShadow = true;
            sceneGroup.add(bgTile);
        }
    }
    
    // カテゴリー名を定義
    const categories = {
        1: 'Resources',
        6: 'Article',
        11: 'Glossary',
        16: 'Person',
        21: 'Others',
        // 追加カテゴリー
        36: 'Projects',
        48: 'Books',
        60: 'Media',
        72: 'Tools',
        100: 'Archive'
    };

    // カテゴリごとの記事数
    const categoryArticleCounts = {
        'Resources': 1000,
        'Article': 20,
        'Glossary': 50,
        'Person': 1000,
        'Others': 100,
        // 追加カテゴリーの記事数
        'Projects': 30,
        'Books': 200,
        'Media': 80,
        'Tools': 45,
        'Archive': 500
    };

    // 記事数から高さを計算する関数
    function calculateHeightFromCount(count) {
        // 対数スケールで高さを計算（値の範囲が広いため）
        const minHeight = 1;
        const maxHeight = 5;
        const minCount = 10;  // 最小記事数（これより少ない場合は最小高さ）
        const maxCount = 1000; // 最大記事数（これより多い場合は最大高さ）
        
        if (count <= minCount) return minHeight;
        if (count >= maxCount) return maxHeight;
        
        // 対数スケールで高さを計算
        const logMinCount = Math.log(minCount);
        const logMaxCount = Math.log(maxCount);
        const logCount = Math.log(count);
        
        // 正規化して高さの範囲にマッピング
        const normalizedHeight = (logCount - logMinCount) / (logMaxCount - logMinCount);
        return minHeight + normalizedHeight * (maxHeight - minHeight);
    }

    // 総記事数を計算
    const totalArticles = Object.values(categoryArticleCounts).reduce((sum, count) => sum + count, 0);
    
    // 総記事数からグリッドサイズを計算
    function calculateGridSize(totalCount) {
        const minArticles = 100;  // この記事数でminGridSize
        const maxArticles = 3000; // この記事数でmaxGridSize
        
        if (totalCount <= minArticles) return minGridSize;
        if (totalCount >= maxArticles) return maxGridSize;
        
        // 線形に補間
        const ratio = (totalCount - minArticles) / (maxArticles - minArticles);
        return Math.floor(minGridSize + ratio * (maxGridSize - minGridSize));
    }
    
    // 現在の記事数に基づいてグリッドサイズを決定
    const currentGridSize = calculateGridSize(totalArticles);
    console.log(`総記事数: ${totalArticles}, グリッドサイズ: ${currentGridSize}`);
    
    // 大陸型配置のタイルを生成
    const continentTiles = createContinentMap(currentGridSize);
    
    // テクスチャーは既に読み込み済み
    
    // タイルを作成して配置
    continentTiles.forEach(tile => {
        const geometry = new THREE.BoxGeometry(tileSize, tile.height, tileSize);
        
        // タイルの種類に応じたマテリアルを作成
        let material;
        
        if (tile.type === 'river') {
            // 川のタイル
            material = new THREE.MeshLambertMaterial({ 
                map: waterTexture,
                color: 0xFFFFFF, // テクスチャーの色を保持するために白色を使用
                transparent: true,
                opacity: 0.9
            });
        } else if (tile.type === 'land') {
            // 地面のタイル
            material = new THREE.MeshLambertMaterial({ 
                map: grassTexture,
                color: 0xFFFFFF // テクスチャーの色を保持するために白色を使用
            });
        } else if (tile.type === 'category' || tile.type === 'article') {
            // カテゴリーと記事のタイル
            material = new THREE.MeshLambertMaterial({ color: tile.color });
        } else if (tile.type === 'topicnote') {
            // Topicnoteのタイル
            material = new THREE.MeshLambertMaterial({ 
                map: sandTexture,
                color: 0xFFD700 // 黄金色を適用
            });
        } else {
            // その他のタイル
            material = new THREE.MeshLambertMaterial({ color: tile.color });
        }
        
        const mesh = new THREE.Mesh(geometry, material);
        
        mesh.position.set(
            tile.x * tileSize,
            tile.height / 2, // 高さの半分
            tile.z * tileSize
        );
        
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        
        // タイルの種類と情報を保存
        mesh.userData = {
            type: tile.type,
            category: tile.category,
            x: tile.x,
            z: tile.z
        };
        
        // クリックイベントの追加
        mesh.callback = function() {
            if (tile.type === 'category') {
                console.log(`カテゴリー: ${tile.category}, 記事数: ${categoryArticleCounts[tile.category]}`);
                // カテゴリー情報を表示するコードをここに追加
            } else if (tile.type === 'topicnote') {
                console.log(`Topicnoteエリア: x=${tile.x}, z=${tile.z}`);
                // Topicnote情報を表示するコードをここに追加
            } else if (tile.type === 'article') {
                console.log(`記事タイル: カテゴリー=${tile.category}, 位置=(${tile.x}, ${tile.z})`);
                // タイルの高さを変更するアニメーション
                const currentHeight = mesh.scale.y;
                const targetHeight = currentHeight < 2 ? 2 : 1;
                
                // アニメーションの設定
                const duration = 500; // ミリ秒
                const startTime = Date.now();
                const startHeight = currentHeight;
                
                function animateHeight() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // イージング関数（簡単なもの）
                    const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                    
                    // 高さを更新
                    const newHeight = startHeight + (targetHeight - startHeight) * easeProgress;
                    mesh.scale.y = newHeight;
                    
                    // 位置も調整（スケールの中心が変わるため）
                    mesh.position.y = (tile.height * newHeight) / 2;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateHeight);
                    }
                }
                
                animateHeight();
            }
        };
        
        tiles.push(mesh);
        sceneGroup.add(mesh);
    });
    
    // Raycasterを使ってクリックしたタイルを検出
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(tiles);
        
        if (intersects.length > 0) {
            const tile = intersects[0].object;
            // タイルをクリックした時の処理
            tile.callback();
        }
    });
    
    // ウィンドウのリサイズ対応
    window.addEventListener('resize', () => {
        const newAspect = window.innerWidth / window.innerHeight;
        camera.left = -10 * newAspect;
        camera.right = 10 * newAspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // アニメーションループ
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();
</script>

<style>
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
    }
    
    #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }
</style>

{{ comp.footer() | safe }}
</body>
</html>
