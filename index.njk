---
layout: layout.njk
title: ホームページ
---

<div class="index-container">
  <canvas id="gridCanvas" style="width: 100%; height: calc(100vh - 100px)"></canvas>
</div>

<style>
  .index-container {
    width: 100%;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
</style>

<script type="module">
  import * as THREE from "https://esm.sh/three@0.150.1";

  // 変数の初期化
  let canvas, scene, camera, renderer;
  let tiles = [];
  let animationFrame;

  // カテゴリーとデータの設定
  const categories = ['Resources', 'Article', 'Grossary', 'Person', 'Others'];
  const articles = []; // ここに記事データが入ります
  
  // カテゴリーごとの記事数を計算
  const categoryCount = categories.reduce((acc, category) => {
    acc[category] = articles.filter(article => article.category === category).length || 1;
    return acc;
  }, {});

  // 初期化関数
  function init() {
    canvas = document.getElementById('gridCanvas');
    if (!canvas) return;

    // シーン作成
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    // レンダラー設定
    renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // キャンバスサイズの設定
    updateCanvasSize();

    // カメラ設定（等角投影）
    const aspect = window.innerWidth / (window.innerHeight - 100); // フッター高さを考慮
    const frustumSize = 10;
    camera = new THREE.OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      1000
    );
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // 光源設定
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // グリッド作成
    createGrid();

    // イベントリスナー
    canvas.addEventListener('click', handleCanvasClick);
    window.addEventListener('resize', handleResize);

    // アニメーション開始
    animate();
  }

  // グリッド作成関数
  function createGrid() {
    const gridSize = 5;
    const tileSize = 1;
    const spacing = 0.1;

    for (let x = 0; x < gridSize; x++) {
      tiles[x] = [];
      for (let z = 0; z < gridSize; z++) {
        // タイルの高さを決定（カテゴリータイルは左端列）
        let height = 0.5;
        let color = 0x6B8E23; // 通常タイル: 緑色

        if (x === 0 && z < categories.length) {
          // カテゴリータイル
          const category = categories[z];
          height = Math.log(categoryCount[category] + 1) * 0.5;
          color = 0x4682B4; // カテゴリータイル: 青色
        }

        // タイルのジオメトリとマテリアル
        const geometry = new THREE.BoxGeometry(tileSize, height, tileSize);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.1,
          roughness: 0.7
        });

        // タイルメッシュ作成
        const tile = new THREE.Mesh(geometry, material);
        
        // タイルの位置設定
        const posX = x * (tileSize + spacing) - (gridSize * (tileSize + spacing)) / 2 + tileSize / 2;
        const posY = height / 2;
        const posZ = z * (tileSize + spacing) - (gridSize * (tileSize + spacing)) / 2 + tileSize / 2;
        
        tile.position.set(posX, posY, posZ);
        
        // シーンに追加
        scene.add(tile);
        tiles[x][z] = tile;
      }
    }
  }

  // アニメーション関数
  function animate() {
    animationFrame = requestAnimationFrame(animate);
    
    // カメラの回転アニメーション（オプション）
    // camera.position.x = 5 * Math.cos(Date.now() * 0.0005);
    // camera.position.z = 5 * Math.sin(Date.now() * 0.0005);
    // camera.lookAt(0, 0, 0);
    
    renderer.render(scene, camera);
  }

  // タイルクリック処理
  function handleCanvasClick(event) {
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera({ x, y }, camera);
    
    const intersects = raycaster.intersectObjects(scene.children);
    
    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;
      
      // タイルを見つける
      tiles.forEach((row, rowIndex) => {
        row.forEach((tile, colIndex) => {
          if (tile === clickedObject) {
            if (rowIndex === 0) {
              // カテゴリータイルクリック処理
              console.log(`カテゴリー: ${categories[colIndex]}`);
              // ここにカテゴリー情報表示ロジックを追加
            } else {
              // 通常タイルクリック処理
              const currentHeight = tile.scale.y;
              // 高さをアニメーションで変更
              const targetHeight = currentHeight === 1 ? 1.5 : 1;
              
              // アニメーション
              const animateTile = () => {
                const diff = targetHeight - tile.scale.y;
                if (Math.abs(diff) < 0.01) {
                  tile.scale.y = targetHeight;
                  return;
                }
                
                tile.scale.y += diff * 0.1;
                requestAnimationFrame(animateTile);
              };
              
              animateTile();
            }
          }
        });
      });
    }
  }

  // リサイズ処理
  function handleResize() {
    updateCanvasSize();
    
    const aspect = window.innerWidth / (window.innerHeight - 100);
    const frustumSize = 10;
    
    camera.left = frustumSize * aspect / -2;
    camera.right = frustumSize * aspect / 2;
    camera.top = frustumSize / 2;
    camera.bottom = frustumSize / -2;
    
    camera.updateProjectionMatrix();
    renderer.render(scene, camera);
  }

  // キャンバスサイズ更新
  function updateCanvasSize() {
    if (!canvas || !renderer) return;
    
    renderer.setSize(window.innerWidth, window.innerHeight - 100);
  }

  // クリーンアップ関数
  function cleanup() {
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
    
    // イベントリスナー削除
    if (canvas) {
      canvas.removeEventListener('click', handleCanvasClick);
    }
    window.removeEventListener('resize', handleResize);
    
    // メモリ解放
    tiles.forEach(row => {
      row.forEach(tile => {
        if (tile.geometry) tile.geometry.dispose();
        if (tile.material instanceof THREE.Material) tile.material.dispose();
      });
    });
    
    if (renderer) {
      renderer.dispose();
    }
  }

  // DOMContentLoadedイベントでの初期化
  document.addEventListener('DOMContentLoaded', init);
  
  // ページ離脱時のクリーンアップ
  window.addEventListener('beforeunload', cleanup);
</script>
